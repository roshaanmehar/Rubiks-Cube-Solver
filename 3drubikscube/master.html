<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .views-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        @media (min-width: 992px) {
            .views-container {
                flex-direction: row;
            }
        }
        
        .view {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }
        
        .view-title {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
            text-align: center;
        }
        
        .cube-3d-container {
            height: 400px;
            position: relative;
        }
        
        .cube-2d-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .cube-2d {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 2px;
            margin-bottom: 20px;
        }
        
        .face-2d {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 2px;
        }
        
        .sticker {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.5);
        }
        
        .sticker.center {
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        
        .control-panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }
        
        .control-title {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .select-container {
            margin-bottom: 15px;
        }
        
        .select-container label {
            display: block;
            margin-bottom: 5px;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        button {
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            background-color: #4299e1;
            color: white;
            cursor: pointer;
            font-weight: 500;
        }
        
        button:hover {
            background-color: #3182ce;
        }
        
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .modal h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .color-picker {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .color-option {
            height: 40px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
        }
        
        .color-option:hover {
            border: 2px solid #000;
        }
        
        .cancel-button {
            width: 100%;
            background-color: #6c757d;
        }
        
        .cancel-button:hover {
            background-color: #5a6268;
        }
        
        .hidden {
            display: none !important;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            background-color: #f8f9fa;
        }
        
        .tab.active {
            background-color: white;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rubik's Cube Visualizer</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="tab-3d">3D View</div>
            <div class="tab" data-tab="tab-2d">2D View</div>
        </div>
        
        <div class="views-container">
            <div class="tab-content active" id="tab-3d">
                <div class="view">
                    <h2 class="view-title">3D Cube</h2>
                    <div class="cube-3d-container" id="cube-3d-container"></div>
                </div>
            </div>
            
            <div class="tab-content" id="tab-2d">
                <div class="view">
                    <h2 class="view-title">2D Cube</h2>
                    <div class="cube-2d-container">
                        <div class="cube-2d" id="cube-2d"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-panel">
                <h3 class="control-title">Controls</h3>
                
                <div class="select-container">
                    <label for="center-color">Center Color</label>
                    <select id="center-color">
                        <option value="white">White</option>
                        <option value="yellow">Yellow</option>
                    </select>
                </div>
                
                <div class="select-container">
                    <label for="face-select">Select Face to Edit</label>
                    <select id="face-select">
                        <option value="">Select a face</option>
                        <option value="front">Front (Red)</option>
                        <option value="back">Back (Orange)</option>
                        <option value="up">Up (Blue)</option>
                        <option value="down">Down (Green)</option>
                        <option value="left">Left (Orange)</option>
                        <option value="right">Right (Red)</option>
                    </select>
                </div>
                
                <div class="select-container">
                    <label for="rotation-direction">Rotation Direction</label>
                    <select id="rotation-direction">
                        <option value="clockwise">Clockwise</option>
                        <option value="counterclockwise">Counter-Clockwise</option>
                    </select>
                </div>
                
                <h4>Rotate Face</h4>
                <div class="button-grid">
                    <button id="rotate-up">Up</button>
                    <button id="rotate-front">Front</button>
                    <button id="rotate-right">Right</button>
                    <button id="rotate-down">Down</button>
                    <button id="rotate-back">Back</button>
                    <button id="rotate-left">Left</button>
                </div>
            </div>
            
            <div class="control-panel">
                <h3 class="control-title">Instructions</h3>
                <ul>
                    <li>Use the tabs to switch between 3D and 2D views</li>
                    <li>Click on any sticker to change its color</li>
                    <li>Use the rotation controls to turn faces</li>
                    <li>In 3D view, drag to rotate the entire cube</li>
                    <li>Changes in one view are reflected in the other</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Color picker modal -->
    <div id="color-picker-modal" class="modal hidden">
        <div class="modal-content">
            <h3>Select Color</h3>
            <div id="color-picker" class="color-picker">
                <div class="color-option" style="background-color: #FF0000;" data-color="0xff0000" data-name="Red"></div>
                <div class="color-option" style="background-color: #FFA500;" data-color="0xffa500" data-name="Orange"></div>
                <div class="color-option" style="background-color: #FFFFFF;" data-color="0xffffff" data-name="White"></div>
                <div class="color-option" style="background-color: #FFFF00;" data-color="0xffff00" data-name="Yellow"></div>
                <div class="color-option" style="background-color: #00FF00;" data-color="0x00ff00" data-name="Green"></div>
                <div class="color-option" style="background-color: #0000FF;" data-color="0x0000ff" data-name="Blue"></div>
            </div>
            <button id="close-color-picker" class="cancel-button">Cancel</button>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Constants for the Rubik's Cube
        const FACE_COLORS = {
            front: 0xff0000, // Red
            back: 0xffa500,  // Orange
            up: 0x0000ff,    // Blue
            down: 0x00ff00,  // Green
            left: 0xffa500,  // Orange
            right: 0xff0000, // Red
            white: 0xffffff, // White
            yellow: 0xffff00 // Yellow
        };
        
        const FACE_NAMES = {
            front: "Front",
            back: "Back",
            up: "Up",
            down: "Down",
            left: "Left",
            right: "Right"
        };
        
        const COLOR_NAMES = {
            "0xff0000": "Red",
            "0xffa500": "Orange",
            "0xffffff": "White",
            "0xffff00": "Yellow",
            "0x00ff00": "Green",
            "0x0000ff": "Blue"
        };
        
        const FACE_LETTERS = {
            front: "F", // Front
            back: "B",  // Back
            up: "U",    // Up
            down: "D",  // Down
            left: "L",  // Left
            right: "R", // Right
        };
        
        // Define face normals for raycasting
        const FACE_NORMALS = {
            front: new THREE.Vector3(0, 0, 1),
            back: new THREE.Vector3(0, 0, -1),
            up: new THREE.Vector3(0, 1, 0),
            down: new THREE.Vector3(0, -1, 0),
            left: new THREE.Vector3(-1, 0, 0),
            right: new THREE.Vector3(1, 0, 0),
        };
        
        // Define the rotation axes for each face
        const ROTATION_AXES = {
            front: new THREE.Vector3(0, 0, 1),
            back: new THREE.Vector3(0, 0, -1),
            up: new THREE.Vector3(0, 1, 0),
            down: new THREE.Vector3(0, -1, 0),
            left: new THREE.Vector3(-1, 0, 0),
            right: new THREE.Vector3(1, 0, 0),
        };
        
        // Map from face to axis and coordinate
        const FACE_TO_AXIS = {
            front: { axis: "z", value: 1 },
            back: { axis: "z", value: -1 },
            up: { axis: "y", value: 1 },
            down: { axis: "y", value: -1 },
            left: { axis: "x", value: -1 },
            right: { axis: "x", value: 1 },
        };
        
        // 2D layout configuration
        const LAYOUT_2D = {
            up: { row: 0, col: 3, rowSpan: 3, colSpan: 3 },
            left: { row: 3, col: 0, rowSpan: 3, colSpan: 3 },
            front: { row: 3, col: 3, rowSpan: 3, colSpan: 3 },
            right: { row: 3, col: 6, rowSpan: 3, colSpan: 3 },
            yellow: { row: 3, col: 9, rowSpan: 3, colSpan: 3 },
            down: { row: 6, col: 3, rowSpan: 3, colSpan: 3 }
        };
        
        // Main Cube Manager class
        class CubeManager {
            constructor() {
                this.cube3D = null;
                this.cube2D = null;
                this.centerColor = "white";
                this.selectedFace = null;
                this.selectedSticker = null;
                this.rotationDirection = "clockwise";
                
                // Initialize cube state
                this.initCubeState();
                
                // Initialize UI
                this.initUI();
                
                // Initialize 3D cube
                this.cube3D = new Cube3D(
                    document.getElementById('cube-3d-container'),
                    this.cubeState,
                    this.handleFaceSelected.bind(this),
                    this.handleRotationComplete.bind(this)
                );
                
                // Initialize 2D cube
                this.cube2D = new Cube2D(
                    document.getElementById('cube-2d'),
                    this.cubeState,
                    this.handleStickerClick.bind(this)
                );
                
                // Initialize color picker
                this.initColorPicker();
            }
            
            initCubeState() {
                // Initialize the cube state with standard colors
                this.cubeState = {
                    front: Array(9).fill(FACE_COLORS.front),
                    back: Array(9).fill(FACE_COLORS.back),
                    up: Array(9).fill(FACE_COLORS.up),
                    down: Array(9).fill(FACE_COLORS.down),
                    left: Array(9).fill(FACE_COLORS.left),
                    right: Array(9).fill(FACE_COLORS.right),
                    white: Array(9).fill(FACE_COLORS.white),
                    yellow: Array(9).fill(FACE_COLORS.yellow)
                };
            }
            
            initUI() {
                // Set up tabs
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        const tabContents = document.querySelectorAll('.tab-content');
                        tabContents.forEach(content => content.classList.remove('active'));
                        
                        const targetTab = tab.getAttribute('data-tab');
                        document.getElementById(targetTab).classList.add('active');
                    });
                });
                
                // Set up face selection
                const faceSelect = document.getElementById('face-select');
                faceSelect.addEventListener('change', (e) => {
                    this.selectedFace = e.target.value;
                    if (this.selectedFace) {
                        this.cube3D.selectFace(this.selectedFace);
                    }
                });
                
                // Set up center color selection
                const centerColorSelect = document.getElementById('center-color');
                centerColorSelect.addEventListener('change', (e) => {
                    this.centerColor = e.target.value;
                    this.cube2D.updateCenterColor(this.centerColor);
                    this.cube3D.updateCenterColor(this.centerColor);
                });
                
                // Set up rotation direction
                const rotationDirectionSelect = document.getElementById('rotation-direction');
                rotationDirectionSelect.addEventListener('change', (e) => {
                    this.rotationDirection = e.target.value;
                });
                
                // Set up rotation buttons
                document.getElementById('rotate-front').addEventListener('click', () => {
                    this.rotateFace('front');
                });
                
                document.getElementById('rotate-back').addEventListener('click', () => {
                    this.rotateFace('back');
                });
                
                document.getElementById('rotate-up').addEventListener('click', () => {
                    this.rotateFace('up');
                });
                
                document.getElementById('rotate-down').addEventListener('click', () => {
                    this.rotateFace('down');
                });
                
                document.getElementById('rotate-left').addEventListener('click', () => {
                    this.rotateFace('left');
                });
                
                document.getElementById('rotate-right').addEventListener('click', () => {
                    this.rotateFace('right');
                });
            }
            
            initColorPicker() {
                const modal = document.getElementById('color-picker-modal');
                const colorPicker = document.getElementById('color-picker');
                const closeButton = document.getElementById('close-color-picker');
                
                // Set up color options
                const colorOptions = colorPicker.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const color = parseInt(option.dataset.color, 16);
                        
                        if (this.selectedSticker) {
                            const { face, index } = this.selectedSticker;
                            this.setFaceColor(face, index, color);
                            modal.classList.add('hidden');
                            this.selectedSticker = null;
                        }
                    });
                });
                
                // Set up close button
                closeButton.addEventListener('click', () => {
                    modal.classList.add('hidden');
                    this.selectedSticker = null;
                });
                
                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.add('hidden');
                        this.selectedSticker = null;
                    }
                });
                
                // Close modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        modal.classList.add('hidden');
                        this.selectedSticker = null;
                    }
                });
            }
            
            handleFaceSelected(face) {
                this.selectedFace = face;
                const faceSelect = document.getElementById('face-select');
                faceSelect.value = face;
            }
            
            handleStickerClick(face, index) {
                // Don't allow changing center stickers
                if (index === 4) return;
                
                this.selectedSticker = { face, index };
                
                // Show color picker
                const modal = document.getElementById('color-picker-modal');
                modal.classList.remove('hidden');
            }
            
            setFaceColor(face, index, color) {
                // Don't allow changing center stickers
                if (index === 4) return;
                
                this.cubeState[face][index] = color;
                
                // Update both views
                this.cube3D.updateCubieColors();
                this.cube2D.updateStickers();
            }
            
            rotateFace(face) {
                const isClockwise = this.rotationDirection === 'clockwise';
                
                // Start rotation in 3D view
                this.cube3D.rotateFace(face, this.rotationDirection);
                
                // Update 2D view immediately (since it doesn't animate)
                const newState = this.updateCubeStateAfterRotation(face, isClockwise);
                this.cubeState = newState;
                this.cube2D.updateStickers();
            }
            
            handleRotationComplete(newState) {
                this.cubeState = newState;
                this.cube2D.updateStickers();
            }
            
            updateCubeStateAfterRotation(face, clockwise) {
                const newState = {};
                Object.keys(this.cubeState).forEach(f => {
                    newState[f] = [...this.cubeState[f]];
                });
                
                // Helper function to rotate a face
                const rotateFace = (face, clockwise) => {
                    const oldFace = [...newState[face]];
                    
                    if (clockwise) {
                        // Rotate clockwise
                        newState[face][0] = oldFace[6];
                        newState[face][1] = oldFace[3];
                        newState[face][2] = oldFace[0];
                        newState[face][3] = oldFace[7];
                        newState[face][4] = oldFace[4]; // Center stays the same
                        newState[face][5] = oldFace[1];
                        newState[face][6] = oldFace[8];
                        newState[face][7] = oldFace[5];
                        newState[face][8] = oldFace[2];
                    } else {
                        // Rotate counter-clockwise
                        newState[face][0] = oldFace[2];
                        newState[face][1] = oldFace[5];
                        newState[face][2] = oldFace[8];
                        newState[face][3] = oldFace[1];
                        newState[face][4] = oldFace[4]; // Center stays the same
                        newState[face][5] = oldFace[7];
                        newState[face][6] = oldFace[0];
                        newState[face][7] = oldFace[3];
                        newState[face][8] = oldFace[6];
                    }
                };
                
                // Rotate the face itself
                rotateFace(face, clockwise);
                
                // Rotate the adjacent faces
                switch (face) {
                    case "front":
                        if (clockwise) {
                            // up -> right -> down -> left -> up
                            const temp = [newState.up[6], newState.up[7], newState.up[8]];
                            [newState.right[0], newState.right[3], newState.right[6]] = [newState.up[8], newState.up[7], newState.up[6]];
                            [newState.down[2], newState.down[1], newState.down[0]] = [newState.right[6], newState.right[3], newState.right[0]];
                            [newState.left[8], newState.left[5], newState.left[2]] = [newState.down[0], newState.down[1], newState.down[2]];
                            [newState.up[6], newState.up[7], newState.up[8]] = [newState.left[2], newState.left[5], newState.left[8]];
                        } else {
                            // up -> left -> down -> right -> up
                            const temp = [newState.up[6], newState.up[7], newState.up[8]];
                            [newState.left[2], newState.left[5], newState.left[8]] = [newState.up[6], newState.up[7], newState.up[8]];
                            [newState.down[0], newState.down[1], newState.down[2]] = [newState.left[8], newState.left[5], newState.left[2]];
                            [newState.right[6], newState.right[3], newState.right[0]] = [newState.down[2], newState.down[1], newState.down[0]];
                            [newState.up[8], newState.up[7], newState.up[6]] = [newState.right[0], newState.right[3], newState.right[6]];
                        }
                        break;
                        
                    case "back":
                        if (clockwise) {
                            // up -> left -> down -> right -> up
                            const temp = [newState.up[0], newState.up[1], newState.up[2]];
                            [newState.left[0], newState.left[3], newState.left[6]] = [newState.up[2], newState.up[1], newState.up[0]];
                            [newState.down[8], newState.down[7], newState.down[6]] = [newState.left[0], newState.left[3], newState.left[6]];
                            [newState.right[8], newState.right[5], newState.right[2]] = [newState.down[6], newState.down[7], newState.down[8]];
                            [newState.up[0], newState.up[1], newState.up[2]] = [newState.right[2], newState.right[5], newState.right[8]];
                        } else {
                            // up -> right -> down -> left -> up
                            const temp = [newState.up[0], newState.up[1], newState.up[2]];
                            [newState.right[2], newState.right[5], newState.right[8]] = [newState.up[0], newState.up[1], newState.up[2]];
                            [newState.down[6], newState.down[7], newState.down[8]] = [newState.right[8], newState.right[5], newState.right[2]];
                            [newState.left[0], newState.left[3], newState.left[6]] = [newState.down[8], newState.down[7], newState.down[6]];
                            [newState.up[2], newState.up[1], newState.up[0]] = [newState.left[0], newState.left[3], newState.left[6]];
                        }
                        break;
                        
                    case "up":
                        if (clockwise) {
                            // back -> right -> front -> left -> back
                            const temp = [newState.back[0], newState.back[1], newState.back[2]];
                            [newState.right[0], newState.right[1], newState.right[2]] = [newState.back[0], newState.back[1], newState.back[2]];
                            [newState.front[0], newState.front[1], newState.front[2]] = [newState.right[0], newState.right[1], newState.right[2]];
                            [newState.left[0], newState.left[1], newState.left[2]] = [newState.front[0], newState.front[1], newState.front[2]];
                            [newState.back[0], newState.back[1], newState.back[2]] = [newState.left[0], newState.left[1], newState.left[2]];
                        } else {
                            // back -> left -> front -> right -> back
                            const temp = [newState.back[0], newState.back[1], newState.back[2]];
                            [newState.left[0], newState.left[1], newState.left[2]] = [newState.back[0], newState.back[1], newState.back[2]];
                            [newState.front[0], newState.front[1], newState.front[2]] = [newState.left[0], newState.left[1], newState.left[2]];
                            [newState.right[0], newState.right[1], newState.right[2]] = [newState.front[0], newState.front[1], newState.front[2]];
                              = [newState.front[0], newState.front[1], newState.front[2]];
                            [newState.back[0], newState.back[1], newState.back[2]] = [newState.right[0], newState.right[1], newState.right[2]];
                        }
                        break;
                        
                    case "down":
                        if (clockwise) {
                            // front -> right -> back -> left -> front
                            const temp = [newState.front[6], newState.front[7], newState.front[8]];
                            [newState.right[6], newState.right[7], newState.right[8]] = [newState.front[6], newState.front[7], newState.front[8]];
                            [newState.back[6], newState.back[7], newState.back[8]] = [newState.right[6], newState.right[7], newState.right[8]];
                            [newState.left[6], newState.left[7], newState.left[8]] = [newState.back[6], newState.back[7], newState.back[8]];
                            [newState.front[6], newState.front[7], newState.front[8]] = [newState.left[6], newState.left[7], newState.left[8]];
                        } else {
                            // front -> left -> back -> right -> front
                            const temp = [newState.front[6], newState.front[7], newState.front[8]];
                            [newState.left[6], newState.left[7], newState.left[8]] = [newState.front[6], newState.front[7], newState.front[8]];
                            [newState.back[6], newState.back[7], newState.back[8]] = [newState.left[6], newState.left[7], newState.left[8]];
                            [newState.right[6], newState.right[7], newState.right[8]] = [newState.back[6], newState.back[7], newState.back[8]];
                            [newState.front[6], newState.front[7], newState.front[8]] = [newState.right[6], newState.right[7], newState.right[8]];
                        }
                        break;
                        
                    case "left":
                        if (clockwise) {
                            // up -> back -> down -> front -> up
                            const temp = [newState.up[0], newState.up[3], newState.up[6]];
                            [newState.back[8], newState.back[5], newState.back[2]] = [newState.up[0], newState.up[3], newState.up[6]];
                            [newState.down[0], newState.down[3], newState.down[6]] = [newState.back[8], newState.back[5], newState.back[2]];
                            [newState.front[0], newState.front[3], newState.front[6]] = [newState.down[0], newState.down[3], newState.down[6]];
                            [newState.up[0], newState.up[3], newState.up[6]] = [newState.front[0], newState.front[3], newState.front[6]];
                        } else {
                            // up -> front -> down -> back -> up
                            const temp = [newState.up[0], newState.up[3], newState.up[6]];
                            [newState.front[0], newState.front[3], newState.front[6]] = [newState.up[0], newState.up[3], newState.up[6]];
                            [newState.down[0], newState.down[3], newState.down[6]] = [newState.front[0], newState.front[3], newState.front[6]];
                            [newState.back[8], newState.back[5], newState.back[2]] = [newState.down[0], newState.down[3], newState.down[6]];
                            [newState.up[0], newState.up[3], newState.up[6]] = [newState.back[8], newState.back[5], newState.back[2]];
                        }
                        break;
                        
                    case "right":
                        if (clockwise) {
                            // up -> front -> down -> back -> up
                            const temp = [newState.up[8], newState.up[5], newState.up[2]];
                            [newState.front[8], newState.front[5], newState.front[2]] = [newState.up[8], newState.up[5], newState.up[2]];
                            [newState.down[8], newState.down[5], newState.down[2]] = [newState.front[8], newState.front[5], newState.front[2]];
                            [newState.back[0], newState.back[3], newState.back[6]] = [newState.down[8], newState.down[5], newState.down[2]];
                            [newState.up[8], newState.up[5], newState.up[2]] = [newState.back[0], newState.back[3], newState.back[6]];
                        } else {
                            // up -> back -> down -> front -> up
                            const temp = [newState.up[8], newState.up[5], newState.up[2]];
                            [newState.back[0], newState.back[3], newState.back[6]] = [newState.up[8], newState.up[5], newState.up[2]];
                            [newState.down[8], newState.down[5], newState.down[2]] = [newState.back[0], newState.back[3], newState.back[6]];
                            [newState.front[8], newState.front[5], newState.front[2]] = [newState.down[8], newState.down[5], newState.down[2]];
                            [newState.up[8], newState.up[5], newState.up[2]] = [newState.front[8], newState.front[5], newState.front[2]];
                        }
                        break;
                }
                
                // Also update the center faces (white/yellow) based on the rotations
                this.updateCenterFaces(newState, face, clockwise);
                
                return newState;
            }
            
            updateCenterFaces(newState, face, clockwise) {
                // Update white and yellow faces based on the rotation
                // This is a simplified approach - in a real cube, these would be affected by rotations
                // of adjacent faces
                
                // For now, we'll just copy the corresponding stickers from the main faces
                if (this.centerColor === "white") {
                    // White is in the center (front)
                    newState.white = [...newState.front];
                    
                    // Yellow is opposite (back)
                    newState.yellow = [...newState.back];
                } else {
                    // Yellow is in the center (front)
                    newState.yellow = [...newState.front];
                    
                    // White is opposite (back)
                    newState.white = [...newState.back];
                }
            }
        }
        
        // 3D Cube class
        class Cube3D {
            constructor(container, cubeState, onFaceSelected, onRotationComplete) {
                this.container = container;
                this.cubeState = cubeState;
                this.onFaceSelected = onFaceSelected;
                this.onRotationComplete = onRotationComplete;
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.cubeGroup = null;
                this.rotationGroup = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.cubies = [];
                this.rotatingFace = null;
                this.rotationDirection = "clockwise";
                this.rotationProgress = 0;
                this.isRotating = false;
                this.cubiePositions = new Map();
                this.cubieToFaceIndices = new Map();
                this.selectedFace = null;
                this.animationFrameId = null;
                this.centerColor = "white";
                
                this.init();
            }
            
            init() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                
                // Create camera
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                this.camera.position.set(6, 5, 7);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;
                this.container.appendChild(this.renderer.domElement);
                
                // Create controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 15;
                
                // Create cube group
                this.cubeGroup = new THREE.Group();
                this.scene.add(this.cubeGroup);
                
                // Create rotation group
                this.rotationGroup = new THREE.Group();
                this.scene.add(this.rotationGroup);
                
                // Create cubies
                this.createCubies();
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Add event listeners
                window.addEventListener('resize', this.handleResize.bind(this));
                this.container.addEventListener('click', this.handleClick.bind(this));
                
                // Start animation loop
                this.animate();
            }
            
            createCubies() {
                // Clear existing cubies
                while (this.cubeGroup.children.length > 0) {
                    this.cubeGroup.remove(this.cubeGroup.children[0]);
                }
                
                this.cubies = [];
                this.cubiePositions.clear();
                this.cubieToFaceIndices.clear();
                
                // Create 27 cubies (3x3x3)
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            // Create cubie
                            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                            const materials = [];
                            
                            // Define materials for each face with default color for inner faces
                            const defaultColor = 0x333333;
                            
                            // Right face (x = 1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: x === 1 ? this.cubeState.right[this.getCubieIndexOnFace("right", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Left face (x = -1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: x === -1 ? this.cubeState.left[this.getCubieIndexOnFace("left", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Up face (y = 1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: y === 1 ? this.cubeState.up[this.getCubieIndexOnFace("up", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Down face (y = -1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: y === -1 ? this.cubeState.down[this.getCubieIndexOnFace("down", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Front face (z = 1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: z === 1 ? this.cubeState.front[this.getCubieIndexOnFace("front", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Back face (z = -1)
                            materials.push(
                                new THREE.MeshStandardMaterial({
                                    color: z === -1 ? this.cubeState.back[this.getCubieIndexOnFace("back", x, y, z)] : defaultColor,
                                    roughness: 0.3,
                                    metalness: 0.2,
                                })
                            );
                            
                            // Create cubie mesh
                            const cubie = new THREE.Mesh(geometry, materials);
                            cubie.position.set(x, y, z);
                            cubie.castShadow = true;
                            cubie.receiveShadow = true;
                            cubie.userData = { x, y, z };
                            this.cubeGroup.add(cubie);
                            this.cubies.push(cubie);
                            
                            // Store cubie position
                            this.cubiePositions.set(cubie, new THREE.Vector3(x, y, z));
                            
                            // Store cubie to face indices mapping
                            const faceIndices = {};
                            if (x === 1) faceIndices.right = this.getCubieIndexOnFace("right", x, y, z);
                            if (x === -1) faceIndices.left = this.getCubieIndexOnFace("left", x, y, z);
                            if (y === 1) faceIndices.up = this.getCubieIndexOnFace("up", x, y, z);
                            if (y === -1) faceIndices.down = this.getCubieIndexOnFace("down", x, y, z);
                            if (z === 1) faceIndices.front = this.getCubieIndexOnFace("front", x, y, z);
                            if (z === -1) faceIndices.back = this.getCubieIndexOnFace("back", x, y, z);
                            this.cubieToFaceIndices.set(cubie, faceIndices);
                            
                            // Add center letters
                            this.addCenterLetters(cubie, x, y, z);
                        }
                    }
                }
            }
            
            addCenterLetters(cubie, x, y, z) {
                // Only add letters to center cubies of each face
                if (Math.abs(x) + Math.abs(y) + Math.abs(z) !== 1) return;
                
                let face = null;
                let direction = null;
                
                if (x === 1) {
                    face = "right";
                    direction = new THREE.Vector3(1, 0, 0);
                } else if (x === -1) {
                    face = "left";
                    direction = new THREE.Vector3(-1, 0, 0);
                } else if (y === 1) {
                    face = "up";
                    direction = new THREE.Vector3(0, 1, 0);
                } else if (y === -1) {
                    face = "down";
                    direction = new THREE.Vector3(0, -1, 0);
                } else if (z === 1) {
                    face = "front";
                    direction = new THREE.Vector3(0, 0, 1);
                } else if (z === -1) {
                    face = "back";
                    direction = new THREE.Vector3(0, 0, -1);
                }
                
                if (face && direction) {
                    const letter = FACE_LETTERS[face];
                    
                    // Create canvas for the letter
                    const canvas = document.createElement("canvas");
                    canvas.width = 128;
                    canvas.height = 128;
                    const context = canvas.getContext("2d");
                    
                    if (context) {
                        context.fillStyle = "#000000";
                        context.font = "bold 80px Arial";
                        context.textAlign = "center";
                        context.textBaseline = "middle";
                        context.fillText(letter, 64, 64);
                        
                        // Create texture from canvas
                        const texture = new THREE.CanvasTexture(canvas);
                        
                        // Create letter mesh
                        const letterGeometry = new THREE.PlaneGeometry(0.5, 0.5);
                        const letterMaterial = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            side: THREE.DoubleSide,
                        });
                        
                        const letterMesh = new THREE.Mesh(letterGeometry, letterMaterial);
                        
                        // Position the letter slightly in front of the cubie face
                        letterMesh.position.copy(direction.clone().multiplyScalar(0.48));
                        letterMesh.lookAt(direction.clone().multiplyScalar(2));
                        
                        cubie.add(letterMesh);
                    }
                }
            }
            
            getCubieIndexOnFace(face, x, y, z) {
                let row = 0, col = 0;
                
                switch (face) {
                    case "front": // z = 1
                        row = 1 - y; // 0, 1, 2 from top to bottom
                        col = x + 1; // 0, 1, 2 from left to right
                        break;
                    case "back": // z = -1
                        row = 1 - y; // 0, 1, 2 from top to bottom
                        col = 1 - x; // 0, 1, 2 from right to left (mirrored)
                        break;
                    case "up": // y = 1
                        row = 1 - z; // 0, 1, 2 from front to back
                        col = x + 1; // 0, 1, 2 from left to right
                        break;
                    case "down": // y = -1
                        row = z + 1; // 0, 1, 2 from back to front
                        col = x + 1; // 0, 1, 2 from left to right
                        break;
                    case "left": // x = -1
                        row = 1 - y; // 0, 1, 2 from top to bottom
                        col = z + 1; // 0, 1, 2 from back to front
                        break;
                    case "right": // x = 1
                        row = 1 - y; // 0, 1, 2 from top to bottom
                        col = 1 - z; // 0, 1, 2 from front to back (mirrored)
                        break;
                }
                
                // Convert 2D coordinates to 1D index (0-8)
                return row * 3 + col;
            }
            
            updateCubieColors() {
                this.cubeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh && Array.isArray(child.material)) {
                        const position = new THREE.Vector3();
                        child.getWorldPosition(position);
                        
                        // Round the position to account for floating point errors
                        const x = Math.round(position.x);
                        const y = Math.round(position.y);
                        const z = Math.round(position.z);
                        
                        // Update the materials based on the cube state
                        const materials = child.material;
                        
                        // Only update colors for faces that are on the outside of the cube
                        if (x === 1 && materials[0] && materials[0].color) {
                            materials[0].color.setHex(this.cubeState.right[this.getCubieIndexOnFace("right", x, y, z)]);
                        }
                        if (x === -1 && materials[1] && materials[1].color) {
                            materials[1].color.setHex(this.cubeState.left[this.getCubieIndexOnFace("left", x, y, z)]);
                        }
                        if (y === 1 && materials[2] && materials[2].color) {
                            materials[2].color.setHex(this.cubeState.up[this.getCubieIndexOnFace("up", x, y, z)]);
                        }
                        if (y === -1 && materials[3] && materials[3].color) {
                            materials[3].color.setHex(this.cubeState.down[this.getCubieIndexOnFace("down", x, y, z)]);
                        }
                        if (z === 1 && materials[4] && materials[4].color) {
                            materials[4].color.setHex(this.cubeState.front[this.getCubieIndexOnFace("front", x, y, z)]);
                        }
                        if (z === -1 && materials[5] && materials[5].color) {
                            materials[5].color.setHex(this.cubeState.back[this.getCubieIndexOnFace("back", x, y, z)]);
                        }
                    }
                });
            }
            
            updateCubiePositions() {
                this.cubiePositions.clear();
                
                this.cubeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const position = new THREE.Vector3();
                        child.getWorldPosition(position);
                        
                        // Round the position to account for floating point errors
                        position.x = Math.round(position.x);
                        position.y = Math.round(position.y);
                        position.z = Math.round(position.z);
                        
                        this.cubiePositions.set(child, position);
                    }
                });
            }
            
            updateCubieToFaceIndices() {
                this.cubieToFaceIndices.clear();
                
                this.cubeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const position = new THREE.Vector3();
                        child.getWorldPosition(position);
                        
                        // Round the position to account for floating point errors
                        const x = Math.round(position.x);
                        const y = Math.round(position.y);
                        const z = Math.round(position.z);
                        
                        // Store cubie to face indices mapping
                        const faceIndices = {};
                        if (x === 1) faceIndices.right = this.getCubieIndexOnFace("right", x, y, z);
                        if (x === -1) faceIndices.left = this.getCubieIndexOnFace("left", x, y, z);
                        if (y === 1) faceIndices.up = this.getCubieIndexOnFace("up", x, y, z);
                        if (y === -1) faceIndices.down = this.getCubieIndexOnFace("down", x, y, z);
                        if (z === 1) faceIndices.front = this.getCubieIndexOnFace("front", x, y, z);
                        if (z === -1) faceIndices.back = this.getCubieIndexOnFace("back", x, y, z);
                        
                        this.cubieToFaceIndices.set(child, faceIndices);
                    }
                });
            }
            
            handleResize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            handleClick(event) {
                if (this.isRotating) return;
                
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Get all cubies from the cube group
                const cubies = [];
                this.cubeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        cubies.push(child);
                    }
                });
                
                const intersects = this.raycaster.intersectObjects(cubies);
                
                if (intersects.length > 0) {
                    const intersectedCubie = intersects[0].object;
                    const faceIndex = Math.floor(intersects[0].faceIndex / 2);
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(intersectedCubie.matrixWorld);
                    const faceNormal = intersects[0].face.normal.clone().applyMatrix3(normalMatrix).normalize();
                    
                    // Determine which face was clicked
                    let clickedFace = null;
                    let minAngle = Number.POSITIVE_INFINITY;
                    
                    Object.entries(FACE_NORMALS).forEach(([face, normal]) => {
                        const angle = faceNormal.angleTo(normal);
                        if (angle < minAngle) {
                            minAngle = angle;
                            clickedFace = face;
                        }
                    });
                    
                    if (clickedFace) {
                        this.selectFace(clickedFace);
                    }
                }
            }
            
            selectFace(face) {
                this.selectedFace = face;
                
                // Call the callback if it exists
                if (this.onFaceSelected) {
                    this.onFaceSelected(face);
                }
            }
            
            rotateFace(face, direction) {
                if (this.isRotating) return;
                
                this.rotatingFace = face;
                this.rotationDirection = direction;
                this.rotationProgress = 0;
                this.isRotating = true;
                
                // Reset rotation group
                this.rotationGroup.rotation.set(0, 0, 0);
                
                // Move cubies from cube group to rotation group based on the face
                const faceInfo = FACE_TO_AXIS[face];
                const cubies = [];
                
                this.cubeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const position = new THREE.Vector3();
                        child.getWorldPosition(position);
                        
                        // Check if the cubie is on the rotating face
                        // We use a small threshold to account for floating point errors
                        const threshold = 0.1;
                        let isOnFace = false;
                        
                        if (faceInfo.axis === "x" && Math.abs(position.x - faceInfo.value) < threshold) isOnFace = true;
                        else if (faceInfo.axis === "y" && Math.abs(position.y - faceInfo.value) < threshold) isOnFace = true;
                        else if (faceInfo.axis === "z" && Math.abs(position.z - faceInfo.value) < threshold) isOnFace = true;
                        
                        if (isOnFace) {
                            cubies.push(child);
                        }
                    }
                });
                
                // Move cubies to rotation group
                cubies.forEach(cubie => {
                    this.cubeGroup.remove(cubie);
                    this.rotationGroup.add(cubie);
                });
            }
            
            updateCenterColor(color) {
                this.centerColor = color;
                // In a real implementation, this would update the cube's center colors
            }
            
            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                if (this.controls) {
                    this.controls.update();
                }
                
                // Handle face rotation animation
                if (this.rotatingFace && this.isRotating) {
                    const rotationSpeed = 0.05;
                    const targetRotation = (Math.PI / 2) * (this.rotationDirection === "clockwise" ? 1 : -1);
                    
                    this.rotationProgress += rotationSpeed;
                    
                    if (this.rotationProgress >= 1) {
                        // Rotation complete
                        this.rotationProgress = 0;
                        this.isRotating = false;
                        
                        // Update the cube state based on the rotation
                        const isClockwise = this.rotationDirection === "clockwise";
                        
                        // Move cubies from rotation group back to cube group
                        while (this.rotationGroup.children.length > 0) {
                            const cubie = this.rotationGroup.children[0];
                            this.rotationGroup.remove(cubie);
                            this.cubeGroup.add(cubie);
                        }
                        
                        // Update the cubie positions map
                        this.updateCubiePositions();
                        
                        // Update the cubie to face indices map
                        this.updateCubieToFaceIndices();
                        
                        // Notify parent component of rotation completion
                        if (this.onRotationComplete) {
                            // Let the parent component handle the state update
                            const newState = {};
                            Object.keys(this.cubeState).forEach(f => {
                                newState[f] = [...this.cubeState[f]];
                            });
                            this.onRotationComplete(newState);
                        }
                        
                        this.rotatingFace = null;
                    } else {
                        // Continue rotation
                        const axis = ROTATION_AXES[this.rotatingFace];
                        this.rotationGroup.setRotationFromAxisAngle(
                            axis,
                            targetRotation * this.rotationProgress
                        );
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            dispose() {
                // Clean up resources
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                this.container.removeChild(this.renderer.domElement);
                this.renderer.dispose();
                
                // Remove event listeners
                window.removeEventListener('resize', this.handleResize);
                this.container.removeEventListener('click', this.handleClick);
            }
        }
        
        // 2D Cube class
        class Cube2D {
            constructor(container, cubeState, onStickerClick) {
                this.container = container;
                this.cubeState = cubeState;
                this.onStickerClick = onStickerClick;
                this.centerColor = "white";
                
                this.render();
            }
            
            render() {
                // Clear container
                this.container.innerHTML = '';
                
                // Create 2D layout
                const layout = document.createElement('div');
                layout.className = 'cube-2d';
                
                // Create faces based on the layout
                Object.entries(LAYOUT_2D).forEach(([face, position]) => {
                    // Skip yellow face if center is white, and vice versa
                    if ((face === 'yellow' && this.centerColor === 'yellow') || 
                        (face === 'white' && this.centerColor === 'white')) {
                        return;
                    }
                    
                    const faceElement = document.createElement('div');
                    faceElement.className = 'face-2d';
                    faceElement.style.gridRow = `${position.row + 1} / span ${position.rowSpan}`;
                    faceElement.style.gridColumn = `${position.col + 1} / span ${position.colSpan}`;
                    
                    // Create stickers
                    for (let i = 0; i < 9; i++) {
                        const sticker = document.createElement('div');
                        sticker.className = 'sticker';
                        if (i === 4) sticker.className += ' center';
                        
                        // Set color
                        const color = this.cubeState[face][i];
                        sticker.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
                        
                        // Add index number
                        sticker.textContent = i;
                        
                        // Add click handler
                        sticker.addEventListener('click', () => {
                            if (this.onStickerClick) {
                                this.onStickerClick(face, i);
                            }
                        });
                        
                        faceElement.appendChild(sticker);
                    }
                    
                    layout.appendChild(faceElement);
                });
                
                this.container.appendChild(layout);
            }
            
            updateStickers() {
                // Re-render the entire 2D view
                this.render();
            }
            
            updateCenterColor(color) {
                this.centerColor = color;
                this.render();
            }
        }
        
        // Initialize the cube manager when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const cubeManager = new CubeManager();
        });
    </script>
</body>
</html>