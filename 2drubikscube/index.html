<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Rubik's 2D – White/Yellow Center</title>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: sans-serif;
      background: #f3f3f3;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto; 
      padding: 20px;
    }
    h1 {
      text-align: center; 
      margin-bottom: 20px;
    }
    .cube-container {
      display: flex; 
      justify-content: center; 
      margin-bottom: 20px;
    }
    /* We have a 5-face net laid out in a plus sign:
         [blue]
     [orange][center][red]
         [green]
    */
    .cube-net {
      display: grid;
      /* 5 rows x 5 columns so we can position each face in a plus shape */
      grid-template-columns: repeat(5, 40px);
      grid-template-rows: repeat(5, 40px);
      gap: 2px;
    }
    .face-2d {
      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 2px;
    }
    .sticker {
      width: 40px; height: 40px;
      border: 1px solid #444;
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 12px; 
      color: rgba(0,0,0,0.6);
      cursor: pointer;
      transition: transform 0.1s;
    }
    .sticker:hover {
      transform: scale(1.03);
    }
    .sticker.center {
      font-weight: bold; 
      color: #000;
    }
    .controls {
      display: flex; 
      flex-wrap: wrap; 
      gap: 20px;
    }
    .control-panel {
      background: #fff; 
      border-radius: 6px; 
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      min-width: 240px;
    }
    .control-panel h2 {
      margin-top: 0;
    }
    .button-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    button {
      padding: 8px; 
      background: #4299e1; 
      border: none; 
      border-radius: 4px; 
      color: #fff; 
      cursor: pointer; 
      font-weight: 500;
    }
    button:hover {
      background: #3182ce;
    }
    .modal {
      position: fixed; 
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex; 
      align-items: center; 
      justify-content: center;
      z-index: 999;
    }
    .modal-content {
      background: #fff; 
      padding: 20px; 
      border-radius: 6px;
      width: 300px;
    }
    .color-picker {
      display: grid; 
      grid-template-columns: repeat(3, 1fr);
      gap: 8px; 
      margin-bottom: 16px;
    }
    .color-option {
      width: 40px; 
      height: 40px; 
      border: 1px solid #ccc; 
      cursor: pointer;
    }
    .color-option:hover {
      border: 2px solid #000;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>2D Rubik's Cube: White/Yellow Center</h1>
  
  <div class="cube-container">
    <div class="cube-net" id="cube-net"></div>
  </div>
  
  <div class="controls">
    <div class="control-panel">
      <h2>Center Color</h2>
      <select id="center-select">
        <option value="white">White Center</option>
        <option value="yellow">Yellow Center</option>
      </select>
      
      <h2>Rotate Direction</h2>
      <select id="rotation-direction">
        <option value="clockwise">Clockwise</option>
        <option value="counterclockwise">Counter-Clockwise</option>
      </select>
      
      <h2>Rotate Face</h2>
      <div class="button-grid">
        <button data-face="center">Center</button>
        <button data-face="green">Green</button>
        <button data-face="red">Red</button>
        <button data-face="blue">Blue</button>
        <button data-face="orange">Orange</button>
        <!-- We do have a hidden face for the "other center" in state, but we do not show a button for it -->
      </div>
    </div>
    
    <div class="control-panel">
      <h2>Instructions</h2>
      <ul>
        <li>Click any non‐center sticker to change color.</li>
        <li>Switch center between White/Yellow at will.</li>
        <li>Rotation only affects that face, ignoring adjacency.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Color Picker Modal -->
<div class="modal hidden" id="color-picker-modal">
  <div class="modal-content">
    <h3>Select Color</h3>
    <div class="color-picker" id="color-picker">
      <div class="color-option" style="background-color:#ff0000"  data-color="0xff0000"></div>
      <div class="color-option" style="background-color:#ffa500" data-color="0xffa500"></div>
      <div class="color-option" style="background-color:#ffffff" data-color="0xffffff"></div>
      <div class="color-option" style="background-color:#ffff00" data-color="0xffff00"></div>
      <div class="color-option" style="background-color:#00ff00" data-color="0x00ff00"></div>
      <div class="color-option" style="background-color:#0000ff" data-color="0x0000ff"></div>
    </div>
    <button id="color-picker-cancel">Cancel</button>
  </div>
</div>

<script>
/*
 We have 6 faces total, each stored as a 9-element array (0..8).
 We'll label them as:
   1) white
   2) yellow
   3) green
   4) blue
   5) red
   6) orange

 We only *render* 5 of these in a plus layout: center, green, red, orange, and blue.
 The center is either "white" or "yellow" per the user’s selection.

 If the center is "white," the side faces (green, red, orange, blue) are oriented so that
 the side face's top row is adjacent to White's bottom row.

 If the center is "yellow," we flip each side face so that the side face's *bottom row*
 is adjacent to Yellow's *top row* (like you said: if green's top row was touching white,
 then green’s bottom row should touch yellow).
*/

// Convenient color hex constants
const COLORS = {
  white:  0xffffff,
  yellow: 0xffff00,
  green:  0x00ff00,
  blue:   0x0000ff,
  red:    0xff0000,
  orange: 0xffa500
};

// Create a default 3x3 face array for a given color
function makeFace(colorHex) {
  return Array(9).fill(colorHex);
}

// Our overall cube state, each face has 9 stickers
const cubeState = {
  white:  makeFace(COLORS.white),
  yellow: makeFace(COLORS.yellow),
  green:  makeFace(COLORS.green),
  blue:   makeFace(COLORS.blue),
  red:    makeFace(COLORS.red),
  orange: makeFace(COLORS.orange)
};

// For building the plus layout, we define the row/col region for each “slot”:
// We'll have 5 faces: center, top(back), bottom(front), left(orange), right(red).
// Each face is 3×3, so we use rowSpan=3 and colSpan=3. 
// We'll place them so that the "center" face is in the middle of this 5×5 grid.
const LAYOUT = {
  center:  { row: 2, col: 2 },
  blue:    { row: 0, col: 2 }, // above center
  green:   { row: 4, col: 2 }, // below center
  orange:  { row: 2, col: 0 }, // left of center
  red:     { row: 2, col: 4 }  // right of center
};

// We’ll keep track of which sticker was clicked
let selectedSticker = null;

// Build the UI
const netContainer = document.getElementById("cube-net");
const centerSelect = document.getElementById("center-select");
const rotationSelect = document.getElementById("rotation-direction");
const modal = document.getElementById("color-picker-modal");
const colorPicker = document.getElementById("color-picker");
const colorPickerCancel = document.getElementById("color-picker-cancel");

// Add event listeners
document.querySelectorAll(".button-grid button").forEach(btn => {
  btn.addEventListener("click", () => {
    const faceName = btn.dataset.face; // e.g. "green", "center", "orange"...
    rotateFace(faceName);
  });
});

colorPickerCancel.addEventListener("click", () => {
  modal.classList.add("hidden");
  selectedSticker = null;
});

modal.addEventListener("click", e => {
  // If user clicks outside the modal-content, close
  if (e.target === modal) {
    modal.classList.add("hidden");
    selectedSticker = null;
  }
});

document.addEventListener("keydown", e => {
  if (e.key === "Escape") {
    modal.classList.add("hidden");
    selectedSticker = null;
  }
});

// Handle picking a color from the color options
colorPicker.querySelectorAll(".color-option").forEach(opt => {
  opt.addEventListener("click", () => {
    const colorVal = parseInt(opt.dataset.color, 16);
    if (selectedSticker) {
      const { face, index } = selectedSticker;
      // set that sticker's color
      if (index !== 4) { // no changing center
        cubeState[face][index] = colorVal;
      }
      modal.classList.add("hidden");
      selectedSticker = null;
      renderNet();
    }
  });
});

// When center is changed, re‐render
centerSelect.addEventListener("change", () => {
  renderNet();
});

// Render the entire net
function renderNet() {
  netContainer.innerHTML = ""; // clear any old DOM

  // We'll build face‐divs for: center, blue, green, orange, red.
  // But which actual face is "center"? -> either "white" or "yellow" per the select
  const centerFaceName = centerSelect.value; // "white" or "yellow"

  // For the side faces, we always show "blue", "green", "orange", "red" face arrays from cubeState
  // But if center is White, we do NOT flip. If center is Yellow, we flip each side 180 degrees
  const shouldFlip = (centerFaceName === "yellow"); 

  // We'll create these five face divs:
  createFaceElement("center", centerFaceName, false); // never flip center
  createFaceElement("blue",  "blue",  shouldFlip);
  createFaceElement("green", "green", shouldFlip);
  createFaceElement("orange","orange",shouldFlip);
  createFaceElement("red",   "red",   shouldFlip);
}

// Utility: create a 3×3 face DIV for faceName, place in net, flipping if needed
function createFaceElement(slot, faceName, flip) {
  const pos = LAYOUT[slot];
  const faceDiv = document.createElement("div");
  faceDiv.classList.add("face-2d");

  // Position in the 5x5 grid (each face is 3 rows x 3 columns)
  faceDiv.style.gridRow = `${pos.row + 1} / span 3`;
  faceDiv.style.gridColumn = `${pos.col + 1} / span 3`;

  // We'll produce an array of 9 indices that says how to map from original
  // face array to the rendered squares. If flip==true, we do a 180 rotation.
  // Index layout (no flip):
  //    0 1 2
  //    3 4 5
  //    6 7 8
  // For a 180° flip, index i goes to 8 - i. 
  let indexMap = [];
  for (let i=0; i<9; i++){
    indexMap.push(flip ? (8 - i) : i);
  }

  // Make 9 stickers
  for (let i=0; i<9; i++){
    const stickerDiv = document.createElement("div");
    stickerDiv.classList.add("sticker");
    if (i === 4) {
      stickerDiv.classList.add("center");
    }
    // fetch the actual color from cubeState[faceName], using indexMap
    const colorHex = cubeState[faceName][ indexMap[i] ];
    stickerDiv.style.backgroundColor = "#" + colorHex.toString(16).padStart(6,"0");
    // show the original index so user can see which sticker it is
    // (some people prefer to show i or indexMap[i] – whichever is more intuitive)
    stickerDiv.textContent = indexMap[i]; 
    
    // If not the center sticker, allow color changes
    if (i !== 4) {
      stickerDiv.addEventListener("click", () => {
        selectedSticker = { face: faceName, index: indexMap[i] };
        modal.classList.remove("hidden");
      });
    }
    faceDiv.appendChild(stickerDiv);
  }

  netContainer.appendChild(faceDiv);
}

// Rotate face in place, ignoring adjacency
function rotateFace(faceSlot) {
  // faceSlot might be "center", "green", "blue", etc.
  // If faceSlot === "center", that means rotate either the "white" or "yellow" face.
  let faceName = faceSlot;
  if (faceSlot === "center") {
    faceName = centerSelect.value; 
  }
  
  // If the user tries to rotate a face that doesn't exist in our state, skip
  if (!cubeState[faceName]) return; 

  const oldArr = [...cubeState[faceName]];
  const newArr = [...oldArr];

  const isClockwise = (rotationSelect.value === "clockwise");
  if (isClockwise) {
    // 0->6, 1->3, 2->0, etc.
    newArr[0] = oldArr[6];
    newArr[1] = oldArr[3];
    newArr[2] = oldArr[0];
    newArr[3] = oldArr[7];
    newArr[4] = oldArr[4]; // center remains
    newArr[5] = oldArr[1];
    newArr[6] = oldArr[8];
    newArr[7] = oldArr[5];
    newArr[8] = oldArr[2];
  } else {
    // counter-clockwise
    newArr[0] = oldArr[2];
    newArr[1] = oldArr[5];
    newArr[2] = oldArr[8];
    newArr[3] = oldArr[1];
    newArr[4] = oldArr[4];
    newArr[5] = oldArr[7];
    newArr[6] = oldArr[0];
    newArr[7] = oldArr[3];
    newArr[8] = oldArr[6];
  }
  cubeState[faceName] = newArr;
  renderNet();
}

// On load, do initial render
document.addEventListener("DOMContentLoaded", renderNet);
</script>
</body>
</html>
