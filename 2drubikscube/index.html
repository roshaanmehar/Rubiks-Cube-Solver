<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Two Iterations: White Center & Yellow Center</title>
  <style>
    body {
      margin: 0; 
      padding: 0; 
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 { text-align: center; margin-bottom: 20px; }

    /* We'll place each iteration in its own container, each 9x9. */
    .iteration-container {
      display: inline-block;
      vertical-align: top;
      margin: 10px;
    }
    .row {
      display: flex;
    }
    .cell {
      width: 40px; 
      height: 40px;
      border: 1px solid #333; 
      box-sizing: border-box;
      margin: 1px;
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 11px;
      color: rgba(0,0,0,0.6);
      cursor: pointer;
    }
    /* Center stickers get a heavier text style, and are not clickable. */
    .center {
      font-weight: bold;
      color: rgba(0,0,0,0.9);
      cursor: default;
    }
    /* Empty (no label) cells – or placeholders – are invisible. */
    .empty {
      border: none;
      cursor: default;
    }

    /* Controls / rotation buttons */
    .controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .control-panel {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      flex: 1;
      min-width: 280px;
    }
    .buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    button {
      padding: 8px; 
      border: none; 
      border-radius: 4px;
      background-color: #4299e1; 
      color: #fff; 
      cursor: pointer; 
      font-weight: 500;
    }
    button:hover {
      background-color: #3182ce;
    }

    /* Modal for color picker */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex; 
      justify-content: center; 
      align-items: center;
      z-index: 999;
    }
    .modal-content {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
    }
    .color-picker {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }
    .color-option {
      width: 40px; 
      height: 40px;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      cursor: pointer;
    }
    .color-option:hover {
      border: 2px solid #000;
    }
    .cancel-btn {
      width: 100%;
      background-color: #6c757d;
    }
    .cancel-btn:hover {
      background-color: #5a6268;
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Two Linked Iterations (White Center & Yellow Center)</h1>

  <!-- Two side-by-side grids -->
  <div class="iteration-container">
    <h2>White-Center Iteration</h2>
    <div id="white-side"></div>
  </div>

  <div class="iteration-container">
    <h2>Yellow-Center Iteration</h2>
    <div id="yellow-side"></div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="control-panel">
      <h2>Rotate a Face (3×3 Matrix)</h2>
      <p>These faces are not “connected.” Each face is its own 3×3. Rotating one face does <em>not</em> affect any others. But rotating from either iteration updates <em>both</em> displays because they share the same data.</p>

      <label for="rotationDir">Rotation Direction:</label>
      <select id="rotationDir">
        <option value="clockwise">Clockwise</option>
        <option value="counterclockwise">Counter-Clockwise</option>
      </select>

      <div class="buttons">
        <button data-face="w">Rotate W</button>
        <button data-face="b">Rotate B</button>
        <button data-face="o">Rotate O</button>
        <button data-face="r">Rotate R</button>
        <button data-face="g">Rotate G</button>
        <button data-face="y">Rotate Y</button>
      </div>
    </div>
    <div class="control-panel">
      <h2>Instructions</h2>
      <ul>
        <li>Two 9×9 layouts. The left has White center, right has Yellow center.</li>
        <li>Click any non-center sticker to recolor; updates appear in both layouts.</li>
        <li>Use buttons to rotate a face’s 3×3 matrix. That rotation also appears in both layouts.</li>
        <li>No adjacency logic – each face is an independent matrix.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Color Picker Modal -->
<div id="colorPickerModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select a Color</h3>
    <div class="color-picker">
      <!-- Red -->
      <div class="color-option" style="background-color:#ff0000" data-color="0xff0000"></div>
      <!-- Orange -->
      <div class="color-option" style="background-color:#ffa500" data-color="0xffa500"></div>
      <!-- White -->
      <div class="color-option" style="background-color:#ffffff" data-color="0xffffff"></div>
      <!-- Yellow -->
      <div class="color-option" style="background-color:#ffff00" data-color="0xffff00"></div>
      <!-- Green -->
      <div class="color-option" style="background-color:#00ff00" data-color="0x00ff00"></div>
      <!-- Blue -->
      <div class="color-option" style="background-color:#0000ff" data-color="0x0000ff"></div>
    </div>
    <button id="cancelColor" class="cancel-btn">Cancel</button>
  </div>
</div>

<script>
/****************************************************************
 * 1) DATA STRUCTURES
 ****************************************************************/
// We have 6 faces: W, B, O, R, G, Y
// Each face is a 3×3 array (9 elements). We'll store them in one
// data object so that rotating or recoloring in "White iteration"
// also updates the "Yellow iteration."

// Initialize each face with a single color (for demo). 
// You can adapt if you want each sticker different, etc.
const faceState = {
  w: Array(9).fill(0xffffff), // White
  b: Array(9).fill(0x0000ff), // Blue
  o: Array(9).fill(0xffa500), // Orange
  r: Array(9).fill(0xff0000), // Red
  g: Array(9).fill(0x00ff00), // Green
  y: Array(9).fill(0xffff00), // Yellow
};

// Standard 3×3 rotation: index mapping
function rotate3x3(arr, clockwise = true) {
  const old = [...arr];
  if (clockwise) {
    arr[0] = old[6]; arr[1] = old[3]; arr[2] = old[0];
    arr[3] = old[7]; arr[4] = old[4]; arr[5] = old[1];
    arr[6] = old[8]; arr[7] = old[5]; arr[8] = old[2];
  } else {
    arr[0] = old[2]; arr[1] = old[5]; arr[2] = old[8];
    arr[3] = old[1]; arr[4] = old[4]; arr[5] = old[7];
    arr[6] = old[0]; arr[7] = old[3]; arr[8] = old[6];
  }
}

/****************************************************************
 * 2) LAYOUT DEFINITIONS
 ****************************************************************/
/*
   White-Center iteration: 9 rows × 9 columns
   Row-by-row from your text (using placeholders for empty columns):
   
   Row0: [ "", "", "", "b1", "b2", "b3", "", "", "" ]
   Row1: [ "", "", "", "b4", "b5", "b6", "", "", "" ]
   Row2: [ "", "", "", "b7", "b8", "b9", "", "", "" ]
   Row3: [ "o1","o2","o3", "w1","w2","w3", "r1","r2","r3" ]
   Row4: [ "o4","o5","o6", "w4","w5","w6", "r4","r5","r6" ]
   Row5: [ "o7","o8","o9", "w7","w8","w9", "r7","r8","r9" ]
   Row6: [ "", "", "", "g1", "g2", "g3", "", "", "" ]
   Row7: [ "", "", "", "g4", "g5", "g6", "", "", "" ]
   Row8: [ "", "", "", "g7", "g8", "g9", "", "", "" ]

   Yellow-Center iteration:
   Row0: [ "", "", "", "g1", "g2", "g3", "", "", "" ]
   Row1: [ "", "", "", "g4", "g5", "g6", "", "", "" ]
   Row2: [ "", "", "", "g7", "g8", "g9", "", "", "" ]
   Row3: [ "o3","o6","o9", "y1","y2","y3", "r7","r4","r1" ]
   Row4: [ "o2","o5","o8", "y4","y5","y6", "r8","r5","r2" ]
   Row5: [ "o1","o4","o7", "y7","y8","y9", "r9","r6","r3" ]
   Row6: [ "", "", "", "b9", "b8", "b7", "", "", "" ]
   Row7: [ "", "", "", "b6", "b5", "b4", "", "", "" ]
   Row8: [ "", "", "", "b3", "b2", "b1", "", "", "" ]
*/

const whiteLayout = [
  ["","","","b1","b2","b3","","",""],
  ["","","","b4","b5","b6","","",""],
  ["","","","b7","b8","b9","","",""],
  ["o1","o2","o3","w1","w2","w3","r1","r2","r3"],
  ["o4","o5","o6","w4","w5","w6","r4","r5","r6"],
  ["o7","o8","o9","w7","w8","w9","r7","r8","r9"],
  ["","","","g1","g2","g3","","",""],
  ["","","","g4","g5","g6","","",""],
  ["","","","g7","g8","g9","","",""]
];

const yellowLayout = [
  ["","","","g1","g2","g3","","",""],
  ["","","","g4","g5","g6","","",""],
  ["","","","g7","g8","g9","","",""],
  ["o3","o6","o9","y1","y2","y3","r7","r4","r1"],
  ["o2","o5","o8","y4","y5","y6","r8","r5","r2"],
  ["o1","o4","o7","y7","y8","y9","r9","r6","r3"],
  ["","","","b9","b8","b7","","",""],
  ["","","","b6","b5","b4","","",""],
  ["","","","b3","b2","b1","","",""]
];

/****************************************************************
 * 3) MAPPING LABELS -> (FACE, INDEX)
 ****************************************************************/
// For example, label "b1" means face='b', index=0; "b2" => index=1, etc.
// "w5" => face='w', index=4, "g9" => face='g', index=8, and so on.
function labelToFaceIndex(label) {
  // label is like "b1", "o7", "y9", "w5", etc. 
  // If empty or invalid, return null.
  if (!label) return null; 

  // First char is face letter; rest is the index
  // e.g. "b1" => letter='b', n='1' => index=0
  const face = label[0]; // 'b','o','w','r','g','y'
  const numStr = label.slice(1); 
  const n = parseInt(numStr, 10);
  if (isNaN(n) || n < 1 || n > 9) return null;

  // face array index is n-1
  return { face, index: n - 1 };
}

// The center sticker is always index=4 for each face (the middle of 3×3).
// So if label => index=4, that cell is "center" (non-clickable).

/****************************************************************
 * 4) RENDER FUNCTIONS
 ****************************************************************/
function renderLayout(containerId, layout) {
  const container = document.getElementById(containerId);
  container.innerHTML = ""; // Clear

  for (let row = 0; row < 9; row++) {
    const rowDiv = document.createElement("div");
    rowDiv.className = "row";

    for (let col = 0; col < 9; col++) {
      const label = layout[row][col];
      if (!label) {
        // Empty
        const cell = document.createElement("div");
        cell.className = "cell empty";
        rowDiv.appendChild(cell);
        continue;
      }

      // We have a sticker label like "b1"
      const map = labelToFaceIndex(label);
      if (!map) {
        // If something invalid, just treat as empty
        const cell = document.createElement("div");
        cell.className = "cell empty";
        rowDiv.appendChild(cell);
        continue;
      }

      const { face, index } = map;
      const cell = document.createElement("div");
      cell.className = "cell";

      // If index=4 => center
      if (index === 4) {
        cell.classList.add("center");
      }

      // Show background color from faceState
      const colorVal = faceState[face][index];
      const hex = colorVal.toString(16).padStart(6,"0");
      cell.style.backgroundColor = "#" + hex;

      // Label text is exactly what's in layout: e.g. "b1", "w5", etc.
      cell.textContent = label;

      // If it's center, don't let user recolor
      if (index !== 4) {
        cell.addEventListener("click", () => {
          openColorPicker(face, index);
        });
      }

      rowDiv.appendChild(cell);
    }
    container.appendChild(rowDiv);
  }
}

// Render both iterations
function renderAll() {
  renderLayout("white-side", whiteLayout);
  renderLayout("yellow-side", yellowLayout);
}

/****************************************************************
 * 5) COLOR PICKER (MODAL)
 ****************************************************************/
let selectedFace = null;
let selectedIndex = null;

const colorPickerModal = document.getElementById("colorPickerModal");
const cancelColorBtn = document.getElementById("cancelColor");
const colorOptions = document.querySelectorAll(".color-option");

function openColorPicker(face, index) {
  selectedFace = face;
  selectedIndex = index;
  colorPickerModal.classList.remove("hidden");
}
function closeColorPicker() {
  selectedFace = null;
  selectedIndex = null;
  colorPickerModal.classList.add("hidden");
}
cancelColorBtn.addEventListener("click", closeColorPicker);
colorPickerModal.addEventListener("click", (e) => {
  if (e.target === colorPickerModal) {
    closeColorPicker();
  }
});
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeColorPicker();
  }
});
colorOptions.forEach(opt => {
  opt.addEventListener("click", () => {
    if (selectedFace !== null && selectedIndex !== null) {
      const colorVal = parseInt(opt.dataset.color, 16);
      // Update the face
      faceState[selectedFace][selectedIndex] = colorVal;
      // Re-render both
      renderAll();
    }
    closeColorPicker();
  });
});

/****************************************************************
 * 6) ROTATION CONTROLS
 ****************************************************************/
document.getElementById("rotationDir").addEventListener("change", (e) => {
  rotationDirection = e.target.value; 
});
let rotationDirection = "clockwise"; // default

const buttons = document.querySelectorAll("button[data-face]");
buttons.forEach(btn => {
  btn.addEventListener("click", () => {
    const face = btn.dataset.face; // 'w','b','o','r','g','y'
    const cw = (rotationDirection === "clockwise");
    rotate3x3(faceState[face], cw);
    renderAll();
  });
});

/****************************************************************
 * 7) INIT
 ****************************************************************/
document.addEventListener("DOMContentLoaded", () => {
  // Initially render
  renderAll();
});
</script>
</body>
</html>
