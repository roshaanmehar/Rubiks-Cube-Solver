<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Two Nets (Face-Based, No Letters)</title>
  <style>
    body {
      margin: 0; 
      padding: 0; 
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .nets {
      display: flex;
      gap: 30px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .net-container {
      text-align: center;
    }
    .grid9x9 {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 1px;
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: rgba(0,0,0,0.5);
      cursor: pointer;
      box-sizing: border-box;
    }
    .empty {
      border: none;
      cursor: default;
    }
    .center {
      font-weight: bold;
      color: rgba(0,0,0,0.8);
      cursor: default;
    }
    .controls {
      margin-top: 30px;
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .control-panel {
      background-color: #fff;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      min-width: 280px;
    }
    .buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    button {
      padding: 8px;
      border: none;
      border-radius: 4px;
      background-color: #4299e1;
      color: #fff;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover {
      background-color: #3182ce;
    }
    /* Color picker modal */
    .modal {
      position: fixed;
      top:0; left:0;
      width:100%; height:100%;
      background-color: rgba(0,0,0,0.5);
      display:flex; justify-content:center; align-items:center;
      z-index:999;
    }
    .modal-content {
      background:#fff;
      padding:20px;
      border-radius:8px;
      width:300px;
    }
    .color-picker {
      display:grid;
      grid-template-columns: repeat(3,1fr);
      gap:8px;
      margin-bottom:15px;
    }
    .color-option {
      width:40px; height:40px;
      border:1px solid #e2e8f0;
      border-radius:4px;
      cursor:pointer;
    }
    .color-option:hover {
      border:2px solid #000;
    }
    .cancel-btn {
      width:100%;
      background-color:#6c757d;
    }
    .cancel-btn:hover {
      background-color:#5a6268;
    }
    .hidden { display:none !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Two Nets (Face-Based, No Letters)</h1>

  <!-- Two 9x9 nets -->
  <div class="nets">
    <!-- White-Center -->
    <div class="net-container">
      <h2>White-Center Layout</h2>
      <div id="whiteNet" class="grid9x9"></div>
    </div>
    <!-- Yellow-Center -->
    <div class="net-container">
      <h2>Yellow-Center Layout</h2>
      <div id="yellowNet" class="grid9x9"></div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="control-panel">
      <h2>Rotate a Face</h2>
      <p>B, O, R, G are linked in both nets. W (white) & Y (yellow) are unlinked.</p>
      <label for="rotateDir">Rotation Direction:</label>
      <select id="rotateDir">
        <option value="cw">Clockwise</option>
        <option value="ccw">Counter-Clockwise</option>
      </select>
      <div class="buttons">
        <button data-face="b">Rotate B</button>
        <button data-face="o">Rotate O</button>
        <button data-face="w">Rotate W</button>
        <button data-face="r">Rotate R</button>
        <button data-face="g">Rotate G</button>
        <button data-face="y">Rotate Y</button>
      </div>
    </div>
    <div class="control-panel">
      <h2>Instructions</h2>
      <ul>
        <li>No adjacency: rotating one face changes only that face’s 3×3 block.</li>
        <li>B/O/R/G <em>shared</em> across both nets; W/Y <em>separate</em> for each net.</li>
        <li>Click any sticker (except center) to recolor it.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Color Picker Modal -->
<div id="colorModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select a Color</h3>
    <div class="color-picker">
      <!-- Red -->
      <div class="color-option" style="background-color:#ff0000" data-color="#ff0000"></div>
      <!-- Orange -->
      <div class="color-option" style="background-color:#ffa500" data-color="#ffa500"></div>
      <!-- White -->
      <div class="color-option" style="background-color:#ffffff" data-color="#ffffff"></div>
      <!-- Yellow -->
      <div class="color-option" style="background-color:#ffff00" data-color="#ffff00"></div>
      <!-- Green -->
      <div class="color-option" style="background-color:#00ff00" data-color="#00ff00"></div>
      <!-- Blue -->
      <div class="color-option" style="background-color:#0000ff" data-color="#0000ff"></div>
    </div>
    <button id="cancelColor" class="cancel-btn">Cancel</button>
  </div>
</div>

<script>
/*******************************************************************************
 * 1) FACE ARRAYS
 *    We'll have 6 faces: b, o, r, g, w, y. Each is a 9-element array of color strings.
 *    B/O/R/G arrays are SHARED between the two nets.
 *    W is used only in the White net. Y is used only in the Yellow net.
 ******************************************************************************/

// We'll initialize each face as a solid color for demo:
let faceB = Array(9).fill("#0000ff"); // Blue
let faceO = Array(9).fill("#ffa500"); // Orange
let faceR = Array(9).fill("#ff0000"); // Red
let faceG = Array(9).fill("#00ff00"); // Green

// White net's 'w' face
let faceW = Array(9).fill("#ffffff"); // White
// Yellow net's 'y' face
let faceY = Array(9).fill("#ffff00"); // Yellow

/*******************************************************************************
 * 2) DEFINING THE 2D LAYOUT FOR EACH NET
 *    Each net is 9 rows x 9 columns. We define which squares map to which face
 *    and which index (0..8) within that face.
 *
 *    White net includes: b, o, w, r, g
 *    Yellow net includes: b, o, y, r, g
 *
 *    For each net, we store a 9x9 array of:
 *       { face:'b', index:0..8 } or null if empty
 ******************************************************************************/

// White net layout (the "plus" shape):
// Row-by-row (9 rows), each an array(9). We'll fill each cell with {face, index}.
const whiteLayout = [
  // Row0
  [ null,null,null, {face:'b',index:0}, {face:'b',index:1}, {face:'b',index:2}, null,null,null ],
  // Row1
  [ null,null,null, {face:'b',index:3}, {face:'b',index:4}, {face:'b',index:5}, null,null,null ],
  // Row2
  [ null,null,null, {face:'b',index:6}, {face:'b',index:7}, {face:'b',index:8}, null,null,null ],
  // Row3
  [ {face:'o',index:0},{face:'o',index:1},{face:'o',index:2},
    {face:'w',index:0},{face:'w',index:1},{face:'w',index:2},
    {face:'r',index:0},{face:'r',index:1},{face:'r',index:2} ],
  // Row4
  [ {face:'o',index:3},{face:'o',index:4},{face:'o',index:5},
    {face:'w',index:3},{face:'w',index:4},{face:'w',index:5},
    {face:'r',index:3},{face:'r',index:4},{face:'r',index:5} ],
  // Row5
  [ {face:'o',index:6},{face:'o',index:7},{face:'o',index:8},
    {face:'w',index:6},{face:'w',index:7},{face:'w',index:8},
    {face:'r',index:6},{face:'r',index:7},{face:'r',index:8} ],
  // Row6
  [ null,null,null, {face:'g',index:0}, {face:'g',index:1}, {face:'g',index:2}, null,null,null ],
  // Row7
  [ null,null,null, {face:'g',index:3}, {face:'g',index:4}, {face:'g',index:5}, null,null,null ],
  // Row8
  [ null,null,null, {face:'g',index:6}, {face:'g',index:7}, {face:'g',index:8}, null,null,null ],
];

// Yellow net layout:
const yellowLayout = [
  // Row0
  [ null,null,null, {face:'g',index:0}, {face:'g',index:1}, {face:'g',index:2}, null,null,null ],
  // Row1
  [ null,null,null, {face:'g',index:3}, {face:'g',index:4}, {face:'g',index:5}, null,null,null ],
  // Row2
  [ null,null,null, {face:'g',index:6}, {face:'g',index:7}, {face:'g',index:8}, null,null,null ],
  // Row3
  [ {face:'o',index:2},{face:'o',index:5},{face:'o',index:8},
    {face:'y',index:0},{face:'y',index:1},{face:'y',index:2},
    {face:'r',index:6},{face:'r',index:3},{face:'r',index:0} ],
  // Row4
  [ {face:'o',index:1},{face:'o',index:4},{face:'o',index:7},
    {face:'y',index:3},{face:'y',index:4},{face:'y',index:5},
    {face:'r',index:7},{face:'r',index:4},{face:'r',index:1} ],
  // Row5
  [ {face:'o',index:0},{face:'o',index:3},{face:'o',index:6},
    {face:'y',index:6},{face:'y',index:7},{face:'y',index:8},
    {face:'r',index:8},{face:'r',index:5},{face:'r',index:2} ],
  // Row6
  [ null,null,null, {face:'b',index:6}, {face:'b',index:7}, {face:'b',index:8}, null,null,null ],
  // Row7
  [ null,null,null, {face:'b',index:3}, {face:'b',index:4}, {face:'b',index:5}, null,null,null ],
  // Row8
  [ null,null,null, {face:'b',index:0}, {face:'b',index:1}, {face:'b',index:2}, null,null,null ],
];

// For convenience, let’s store a dictionary for the faces so we can read/update them easily:
const faceData = {
  b: faceB, // shared
  o: faceO, // shared
  r: faceR, // shared
  g: faceG, // shared
  w: faceW, // White only
  y: faceY  // Yellow only
};

/*******************************************************************************
 * 3) RENDERING A 9×9 NET
 *    For each cell, we find {face, index}, then get faceData[face][index] for color.
 *    If index===4 => center.
 *    We show the text as "face + index" for debugging or can just show blank text.
 ******************************************************************************/
function renderNet(containerId, layout) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";
  for (let row=0; row<9; row++){
    for (let col=0; col<9; col++){
      const info = layout[row][col];
      const cellDiv = document.createElement("div");
      cellDiv.className="cell";

      if (!info) {
        // empty
        cellDiv.classList.add("empty");
        container.appendChild(cellDiv);
        continue;
      }

      // info => {face:'b', index:0..8}
      const { face, index } = info;
      const color = faceData[face][index];
      cellDiv.style.backgroundColor = color;

      // center?
      if (index===4) {
        cellDiv.classList.add("center");
      }
      // Optionally we can show text "face + index" or just the index
      // cellDiv.textContent = face + index;
      // We'll just show index for clarity:
      cellDiv.textContent = index;

      // clickable if index!==4
      if (index!==4) {
        cellDiv.addEventListener("click", ()=>{
          openColorPicker(face, index);
        });
      }

      container.appendChild(cellDiv);
    }
  }
}

/** Re-render both the White net and Yellow net. */
function renderAll() {
  renderNet("whiteNet", whiteLayout);
  renderNet("yellowNet", yellowLayout);
}

/*******************************************************************************
 * 4) COLOR PICKER (MODAL)
 ******************************************************************************/
const colorModal = document.getElementById("colorModal");
const cancelBtn   = document.getElementById("cancelColor");
const colorOpts   = document.querySelectorAll(".color-option");

let currentFace=null, currentIndex=null;

function openColorPicker(face, index){
  currentFace= face; 
  currentIndex= index;
  colorModal.classList.remove("hidden");
}
function closeColorPicker(){
  currentFace=null;
  currentIndex=null;
  colorModal.classList.add("hidden");
}
cancelBtn.addEventListener("click", closeColorPicker);
colorModal.addEventListener("click", (e)=>{
  if (e.target===colorModal){
    closeColorPicker();
  }
});
document.addEventListener("keydown",(e)=>{
  if(e.key==="Escape"){
    closeColorPicker();
  }
});

// If user picks a color
colorOpts.forEach(opt=>{
  opt.addEventListener("click", ()=>{
    if (currentFace==null) return;
    const newColor= opt.dataset.color;

    // update face array
    faceData[currentFace][currentIndex] = newColor;

    renderAll();
    closeColorPicker();
  });
});

/*******************************************************************************
 * 5) ROTATION
 *    We'll define a standard 3×3 index rotation:
 *      For a face array [0..8], arranged as:
 *        0 1 2
 *        3 4 5
 *        6 7 8
 *      rotating cw => new positions
 *        0->6, 1->3, 2->0, 3->7, 4->4, 5->1, 6->8, 7->5, 8->2
 ******************************************************************************/
const cwMap = [6,3,0,7,4,1,8,5,2];
const ccwMap= [2,5,8,1,4,7,0,3,6];

/** Rotate face array in place. */
function rotateFaceArray(arr, clockwise=true){
  const old = [...arr];
  if (clockwise){
    arr[0]= old[6]; arr[1]= old[3]; arr[2]= old[0];
    arr[3]= old[7]; arr[4]= old[4]; arr[5]= old[1];
    arr[6]= old[8]; arr[7]= old[5]; arr[8]= old[2];
  } else {
    arr[0]= old[2]; arr[1]= old[5]; arr[2]= old[8];
    arr[3]= old[1]; arr[4]= old[4]; arr[5]= old[7];
    arr[6]= old[0]; arr[7]= old[3]; arr[8]= old[6];
  }
}

/*******************************************************************************
 * 6) HOOKING UP ROTATION BUTTONS
 *    b, o, r, g => shared face arrays => rotate => affects both nets
 *    w => only the White net’s faceW
 *    y => only the Yellow net’s faceY
 ******************************************************************************/
document.getElementById("rotateDir").addEventListener("change", (e)=>{
  rotationDir= e.target.value;
});
let rotationDir="cw";

document.querySelectorAll("button[data-face]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const face= btn.dataset.face; // 'b','o','r','g','w','y'
    const cw= (rotationDir==="cw");

    rotateFaceArray(faceData[face], cw);
    // re-render
    renderAll();
  });
});

/*******************************************************************************
 * 7) INITIALIZE
 ******************************************************************************/
document.addEventListener("DOMContentLoaded", ()=>{
  renderAll();
});
</script>
</body>
</html>
