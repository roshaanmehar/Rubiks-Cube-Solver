<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Two Nets, Linked by Label (B/O/R/G), Unlinked W/Y</title>
  <style>
    body {
      margin:0; padding:0;
      font-family:Arial,sans-serif;
      background-color:#f0f0f0;
    }
    .container {
      max-width:1400px;
      margin:0 auto;
      padding:20px;
    }
    h1 { text-align:center; margin-bottom:20px; }
    .nets {
      display:flex; gap:30px; justify-content:center; flex-wrap:wrap;
    }
    .net-container { text-align:center; }

    .grid9x9 {
      display:grid;
      grid-template-columns:repeat(9,40px);
      grid-template-rows:repeat(9,40px);
      gap:1px;
      margin-bottom:20px;
    }
    .cell {
      width:40px; height:40px;
      border:1px solid #333;
      display:flex; align-items:center; justify-content:center;
      font-size:12px;
      color:rgba(0,0,0,0.7);
      cursor:pointer;
      box-sizing:border-box;
    }
    .empty {
      border:none; cursor:default;
    }
    .center {
      font-weight:bold;
      color:rgba(0,0,0,0.9);
      cursor:default;
    }

    .controls {
      margin-top:25px;
      display:flex; gap:20px; justify-content:center; flex-wrap:wrap;
    }
    .control-panel {
      background:#fff;
      border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,0.1);
      padding:15px; min-width:280px;
    }
    .buttons {
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:8px; margin-top:10px;
    }
    button {
      padding:8px;
      border:none;
      border-radius:4px;
      background-color:#4299e1;
      color:#fff;
      cursor:pointer;
      font-weight:500;
    }
    button:hover { background-color:#3182ce; }

    .modal {
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.5);
      display:flex; align-items:center; justify-content:center;
      z-index:999;
    }
    .modal-content {
      background:#fff;
      padding:20px;
      border-radius:8px;
      width:300px;
    }
    .color-picker {
      display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:15px;
    }
    .color-option {
      width:40px; height:40px;
      border:1px solid #e2e8f0;
      border-radius:4px;
      cursor:pointer;
    }
    .color-option:hover { border:2px solid #000; }
    .cancel-btn {
      width:100%;
      background-color:#6c757d;
    }
    .cancel-btn:hover { background-color:#5a6268; }
    .hidden { display:none !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Two Nets, Linked by Label (B/O/R/G), Unlinked W/Y</h1>

  <div class="nets">
    <div class="net-container">
      <h2>White-Center Layout</h2>
      <div id="whiteGrid" class="grid9x9"></div>
    </div>
    <div class="net-container">
      <h2>Yellow-Center Layout</h2>
      <div id="yellowGrid" class="grid9x9"></div>
    </div>
  </div>

  <div class="controls">
    <div class="control-panel">
      <h2>Rotate a Face</h2>
      <p>Digits (1..9) stay put, letters shift. B/O/R/G are label-linked across nets; W/Y are unlinked.</p>
      <label for="rotateDir">Direction:</label>
      <select id="rotateDir">
        <option value="cw">Clockwise</option>
        <option value="ccw">Counterclockwise</option>
      </select>
      <div class="buttons">
        <button data-face="b">Rotate B</button>
        <button data-face="o">Rotate O</button>
        <button data-face="w">Rotate W</button>
        <button data-face="r">Rotate R</button>
        <button data-face="g">Rotate G</button>
        <button data-face="y">Rotate Y</button>
      </div>
    </div>
    <div class="control-panel">
      <h2>Instructions</h2>
      <ul>
        <li>Click a non‐center cell to change its letter. If it’s B/O/R/G, the same label is updated in both nets.</li>
        <li>White (W) is only in the left net; Yellow (Y) only in the right net. Those do not link.</li>
        <li>Rotation is face‐by‐face, shuffling letters among the 9 squares of that face. The digits remain fixed positions in the net.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Color Picker Modal -->
<div id="colorModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select a Color</h3>
    <div class="color-picker">
      <div class="color-option" style="background-color:#ff0000" data-letter="r"></div>
      <div class="color-option" style="background-color:#ffa500" data-letter="o"></div>
      <div class="color-option" style="background-color:#ffffff" data-letter="w"></div>
      <div class="color-option" style="background-color:#ffff00" data-letter="y"></div>
      <div class="color-option" style="background-color:#00ff00" data-letter="g"></div>
      <div class="color-option" style="background-color:#0000ff" data-letter="b"></div>
    </div>
    <button id="cancelColor" class="cancel-btn">Cancel</button>
  </div>
</div>

<script>
/**********************************************************************
 * 1) Layout Strings
 **********************************************************************/
// White side
const whiteStrings = [
  ["","","","b9","b8","b7","","",""],
  ["","","","b6","b5","b4","","",""],
  ["","","","b3","b2","b1","","",""],
  ["o7","o4","o1","w1","w2","w3","r3","r6","r9"],
  ["o8","o5","o2","w4","w5","w6","r2","r5","r8"],
  ["o9","o6","o3","w7","w8","w9","r1","r4","r7"],
  ["","","","g1","g2","g3","","",""],
  ["","","","g4","g5","g6","","",""],
  ["","","","g7","g8","g9","","",""]
];
// Yellow side
const yellowStrings = [
  ["","","","g1","g2","g3","","",""],
  ["","","","g4","g5","g6","","",""],
  ["","","","g7","g8","g9","","",""],
  ["o3","o6","o9","y1","y2","y3","r7","r4","r1"],
  ["o2","o5","o8","y4","y5","y6","r8","r5","r2"],
  ["o1","o4","o7","y7","y8","y9","r9","r6","r3"],
  ["","","","b9","b8","b7","","",""],
  ["","","","b6","b5","b4","","",""],
  ["","","","b3","b2","b1","","",""]
];

/**********************************************************************
 * 2) Parse layouts into 9×9 arrays: { digit, letter, label } or null
 **********************************************************************/
function parseLayout(stringRows) {
  const grid = [];
  for (let r=0; r<9; r++) {
    const rowArr = [];
    for (let c=0; c<9; c++) {
      const token = stringRows[r][c] || "";
      if (!token) {
        rowArr.push(null);
      } else {
        const letter = token[0];         // e.g. 'r'
        const digit = parseInt(token.slice(1), 10); // e.g. 1
        const label = letter + digit;    // e.g. 'r1'
        rowArr.push({ digit, letter, label });
      }
    }
    grid.push(rowArr);
  }
  return grid;
}
let whiteGrid = parseLayout(whiteStrings);
let yellowGrid= parseLayout(yellowStrings);

/**********************************************************************
 * 3) Build a global map from label -> array of references
 *    e.g. labelMap["r1"] = [ { net:"white", row, col }, { net:"yellow", row, col } ]
 *    so we can quickly update the same label in both nets if it's b/o/r/g.
 **********************************************************************/
let labelMap = {};

/** Rebuild the labelMap from scratch, scanning both grids. */
function rebuildLabelMap() {
  labelMap = {};
  // scan White
  for (let r=0; r<9; r++){
    for (let c=0; c<9; c++){
      const cell = whiteGrid[r][c];
      if (cell && cell.label) {
        if (!labelMap[cell.label]) labelMap[cell.label] = [];
        labelMap[cell.label].push({ net:"white", row:r, col:c });
      }
    }
  }
  // scan Yellow
  for (let r=0; r<9; r++){
    for (let c=0; c<9; c++){
      const cell = yellowGrid[r][c];
      if (cell && cell.label) {
        if (!labelMap[cell.label]) labelMap[cell.label] = [];
        labelMap[cell.label].push({ net:"yellow", row:r, col:c });
      }
    }
  }
}

/**********************************************************************
 * 4) Rendering the 9×9 grids
 **********************************************************************/
function renderGrid(containerId, gridData) {
  const container = document.getElementById(containerId);
  container.innerHTML="";
  for (let r=0; r<9; r++){
    for (let c=0; c<9; c++){
      const cell = gridData[r][c];
      const div = document.createElement("div");
      div.className = "cell";
      if (!cell) {
        div.classList.add("empty");
        container.appendChild(div);
        continue;
      }
      if (cell.digit===5) {
        div.classList.add("center");
      }
      // background color
      div.style.backgroundColor = letterToColor(cell.letter);
      // text: cell.label, e.g. "r1"
      div.textContent = cell.label;

      // clickable if digit !=5
      if (cell.digit!==5) {
        div.addEventListener("click", ()=>onCellClick(containerId, r, c));
      }
      container.appendChild(div);
    }
  }
}

function renderAll() {
  renderGrid("whiteGrid", whiteGrid);
  renderGrid("yellowGrid", yellowGrid);
}

/** letter -> color */
function letterToColor(letter){
  switch(letter){
    case 'b':return "#0000ff";
    case 'o':return "#ffa500";
    case 'r':return "#ff0000";
    case 'g':return "#00ff00";
    case 'w':return "#ffffff";
    case 'y':return "#ffff00";
    default: return "#999";
  }
}

/**********************************************************************
 * 5) Clicking a cell to recolor it
 *    We read the old label, pick a new letter, rebuild labelMap.
 **********************************************************************/
let selectedGridId=null, selectedRow=null, selectedCol=null;
const modal = document.getElementById("colorModal");
const cancelBtn = document.getElementById("cancelColor");
const colorOptions = document.querySelectorAll(".color-option");

function onCellClick(gridId, row, col){
  selectedGridId= gridId;
  selectedRow= row;
  selectedCol= col;
  modal.classList.remove("hidden");
}

function closeColorPicker(){
  selectedGridId=null;
  selectedRow=null;
  selectedCol=null;
  modal.classList.add("hidden");
}

cancelBtn.addEventListener("click", closeColorPicker);
modal.addEventListener("click", (e)=>{
  if(e.target===modal){
    closeColorPicker();
  }
});
document.addEventListener("keydown", (e)=>{
  if(e.key==="Escape"){
    closeColorPicker();
  }
});

colorOptions.forEach(opt=>{
  opt.addEventListener("click", ()=>{
    if(selectedGridId==null) return;
    const newLetter = opt.dataset.letter; // e.g. 'r'
    let gridData = (selectedGridId==="whiteGrid")? whiteGrid : yellowGrid;
    let cell = gridData[selectedRow][selectedCol];
    if(!cell) return;

    const oldLetter= cell.letter;  // e.g. 'r'
    const oldDigit= cell.digit;    // e.g. 1
    const oldLabel= cell.label;    // e.g. 'r1'

    // set the new letter
    cell.letter= newLetter;
    cell.label = newLetter + oldDigit; // e.g. 'b1'

    // Now, if oldLetter was among b/o/r/g, it means the oldLabel had possible references in labelMap.
    // If newLetter is among b/o/r/g, we want to update them to the new label. 
    // If newLetter is w/y, we do NOT mirror across nets, so we remove from the old references on the other net.
    handleLabelChange(oldLabel, cell.label);

    rebuildLabelMap();
    renderAll();
    closeColorPicker();
  });
});

/** Called after we recolor a cell from oldLabel->newLabel. 
    - If oldLetter was b/o/r/g and newLetter is also b/o/r/g, rename in the other net from oldLabel->newLabel.
    - If newLetter is w/y, remove from the other net. 
*/
function handleLabelChange(oldLabel, newLabel){
  const oldLetter= oldLabel[0];
  const newLetter= newLabel[0];
  const wasLinked= ["b","o","r","g"].includes(oldLetter);
  const isLinked= ["b","o","r","g"].includes(newLetter);

  if(!labelMap[oldLabel]) return; // no references => done

  // For each reference that used to have oldLabel
  let refs= labelMap[oldLabel];
  for(let i=0; i<refs.length; i++){
    let { net, row, col } = refs[i];
    // find the cell in that net
    let netData= (net==="white")? whiteGrid : yellowGrid;
    let cell= netData[row][col];
    if(!cell) continue;
    if(cell.label!==oldLabel) continue;

    if(isLinked){
      // rename to newLabel
      cell.letter= newLetter;
      cell.label = newLabel;
    } else {
      // newLetter is w/y => remove from the other net
      // e.g. set letter=null or something
      // But we want to keep the digit. We'll just clear letter/label:
      cell.letter= null;
      cell.label= "";
    }
  }
}

/**********************************************************************
 * 6) Rotation
 *    We define each face's 9 squares by row/col. Then rotating
 *    rearranges the letters among them. The digits remain the same,
 *    but we update each cell's label = letter + digit.
 **********************************************************************/
const cwMap = [6,3,0,7,4,1,8,5,2];
const ccwMap= [2,5,8,1,4,7,0,3,6];

// For White net: B,O,W,R,G are present. Y is not.
const faceCoordsWhite = {
  b: [
    {r:0,c:3},{r:0,c:4},{r:0,c:5},
    {r:1,c:3},{r:1,c:4},{r:1,c:5},
    {r:2,c:3},{r:2,c:4},{r:2,c:5}
  ],
  o: [
    {r:3,c:0},{r:3,c:1},{r:3,c:2},
    {r:4,c:0},{r:4,c:1},{r:4,c:2},
    {r:5,c:0},{r:5,c:1},{r:5,c:2}
  ],
  w: [
    {r:3,c:3},{r:3,c:4},{r:3,c:5},
    {r:4,c:3},{r:4,c:4},{r:4,c:5},
    {r:5,c:3},{r:5,c:4},{r:5,c:5}
  ],
  r: [
    {r:3,c:6},{r:3,c:7},{r:3,c:8},
    {r:4,c:6},{r:4,c:7},{r:4,c:8},
    {r:5,c:6},{r:5,c:7},{r:5,c:8}
  ],
  g: [
    {r:6,c:3},{r:6,c:4},{r:6,c:5},
    {r:7,c:3},{r:7,c:4},{r:7,c:5},
    {r:8,c:3},{r:8,c:4},{r:8,c:5}
  ],
  y: [] // not present in the white net
};

// For Yellow net: G,O,Y,R,B are present. W is not.
const faceCoordsYellow = {
  g: [
    {r:0,c:3},{r:0,c:4},{r:0,c:5},
    {r:1,c:3},{r:1,c:4},{r:1,c:5},
    {r:2,c:3},{r:2,c:4},{r:2,c:5}
  ],
  o: [
    {r:3,c:0},{r:3,c:1},{r:3,c:2},
    {r:4,c:0},{r:4,c:1},{r:4,c:2},
    {r:5,c:0},{r:5,c:1},{r:5,c:2}
  ],
  y: [
    {r:3,c:3},{r:3,c:4},{r:3,c:5},
    {r:4,c:3},{r:4,c:4},{r:4,c:5},
    {r:5,c:3},{r:5,c:4},{r:5,c:5}
  ],
  r: [
    {r:3,c:6},{r:3,c:7},{r:3,c:8},
    {r:4,c:6},{r:4,c:7},{r:4,c:8},
    {r:5,c:6},{r:5,c:7},{r:5,c:8}
  ],
  b: [
    {r:6,c:3},{r:6,c:4},{r:6,c:5},
    {r:7,c:3},{r:7,c:4},{r:7,c:5},
    {r:8,c:3},{r:8,c:4},{r:8,c:5}
  ],
  w: []
};

/** Rotate the 9 squares in a net's face. We gather their letters, reorder them, and reassign. */
function rotateFace(netData, coords, clockwise){
  if(!coords || coords.length<9) return;
  // Gather 9 squares
  let squares = coords.map(pos => {
    let cell = netData[pos.r][pos.c];
    return cell ? { ...cell } : { digit:0, letter:null, label:"" };
  });
  const map = clockwise? cwMap : ccwMap;
  // Reassign each index's letter to new index
  for(let i=0; i<9; i++){
    let newIdx= map[i]; // where squares[i]'s letter goes
    let { digit, letter } = squares[i];
    // place letter in squares[newIdx]'s location in netData
    let pos= coords[newIdx];
    let cell = netData[pos.r][pos.c];
    if(cell){
      cell.letter= letter;
      cell.label = letter? (letter+cell.digit) : "";
    }
  }
}

/**********************************************************************
 * 7) Hook up rotate buttons
 **********************************************************************/
const rotateDirSel = document.getElementById("rotateDir");
let rotationDir="cw";
rotateDirSel.addEventListener("change", ()=>{
  rotationDir= rotateDirSel.value; // "cw" or "ccw"
});

document.querySelectorAll("[data-face]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const face= btn.dataset.face; // 'b','o','r','g','w','y'
    const cw= (rotationDir==="cw");

    // If face is among b/o/r/g => we rotate in both nets
    // If face= w => only white net
    // If face= y => only yellow net
    if(face==="w"){
      rotateFace(whiteGrid, faceCoordsWhite.w, cw);
    }
    else if(face==="y"){
      rotateFace(yellowGrid, faceCoordsYellow.y, cw);
    }
    else {
      // b/o/r/g => rotate in both
      rotateFace(whiteGrid, faceCoordsWhite[face], cw);
      rotateFace(yellowGrid, faceCoordsYellow[face], cw);
    }

    // After rotation, we changed many cell letters => must fix labels, rebuild labelMap
    fixLabels(whiteGrid);
    fixLabels(yellowGrid);
    rebuildLabelMap();
    renderAll();
  });
});

/** fixLabels: for each cell, label= letter+digit */
function fixLabels(netData){
  for(let r=0; r<9; r++){
    for(let c=0; c<9; c++){
      let cell= netData[r][c];
      if(cell && cell.letter){
        cell.label= cell.letter+ cell.digit;
      } else if(cell) {
        cell.label= "";
      }
    }
  }
}

/**********************************************************************
 * 8) INIT
 **********************************************************************/
document.addEventListener("DOMContentLoaded", ()=>{
  rebuildLabelMap();
  renderAll();
});
</script>
</body>
</html>
